#pragma once
#include "./aio_base.h"
#include "../../L0/containers/pool.h"
#include <aio.h>
#include <stdlib.h>
#include <memory.h>
#include <unistd.h>
namespace aio_l3 {
    class linux_aio :public aio {
        allocator_l0::allocator *_allocator;
        class my_aio_file;
        container_l0::pool<> _done_tasks;
        class my_task :public aio_task, public container_l0::pool_node {
            my_aio_file *_file;

            ret_code _state;
            int _trans_size;
            int _error;
            aiocb _io_data;
            static void call_back(sigval_t _sigval) {
                my_task *task = static_cast<my_task *>(_sigval.sival_ptr);
                task->on_finished();
            }
            void on_finished() {

                assert ( _state != io_canceled );
                int ret = aio_error( &_io_data );
                assert ( ret == 0 );
                assert ( _state == io_wait );

                _trans_size = aio_return(&_io_data);
                _state = ( _trans_size >= 0 )
                    ? io_success
                    : (_io_data.aio_lio_opcode == LIO_READ) 
                    ? read_faild
                    : write_faild;
                _file->on_finished(this); 
            }
        public:
            bool _destroyed;
            virtual void destroy() {

                if ( _destroyed || ( _state == io_canceled ) ) {

                    allocator_l0::allocator *alloc = _file->get_allocator();
                    this->~my_task();
                    alloc->deallocate(this);
                }
                else _destroyed = true;
            }
            virtual void cancel() {
                if ( ( _state == io_canceled ) || ( _state == io_success ) ) return;
                if ( aio_cancel(_file->fd(), &_io_data) == AIO_CANCELED ) _state = io_canceled;
            }
            virtual ret_code state() const { return _state; }
            virtual int err_code() const { return _error; }
            virtual int trans_size() const { return _trans_size; }
            virtual char *data() const { return (char*)_io_data.aio_buf; }
            virtual aio_file *owner() { return _file; }

            my_task(char *data, dword_t size, qword_t offset, bool is_read, my_aio_file *file, int fd)
            :_file(file), _state(io_wait), _trans_size(0), _destroyed(false), _error(0){
                memset(&_io_data, 0, sizeof(_io_data));
                _io_data.aio_fildes = fd;
                _io_data.aio_lio_opcode = is_read? LIO_READ: LIO_WRITE;
                _io_data.aio_nbytes = size;
                _io_data.aio_offset = offset;

                _io_data.aio_sigevent.sigev_notify = SIGEV_THREAD;
                _io_data.aio_sigevent.sigev_notify_function = &my_task::call_back;
                _io_data.aio_sigevent.sigev_notify_attributes = 0;
                _io_data.aio_sigevent.sigev_value.sival_ptr = this;
                _io_data.aio_buf = data;

                if ( is_read ) {
                    if (aio_read(&_io_data) != 0) 
                        _state = read_faild;
                }
                else {
                    if (aio_write(&_io_data) != 0) 
                        _state = write_faild;
                }
            }
            ~my_task() {

            }
        };
        class my_aio_file :public aio_file {
            linux_aio *_inst;
            int _fd;
        public:
            int fd() const { return _fd; }
            void on_finished(my_task *task) { _inst->on_finished(task); }

            my_aio_file(const char *file_name, int open_mode, linux_aio *inst) 
            :_inst(inst) {
                _fd = (open_mode & O_CREAT)
                    ? open(file_name, open_mode, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
                    : open(file_name, open_mode);
            }

            ~my_aio_file() { if ( _fd != -1 ) close(_fd); }

            allocator_l0::allocator *get_allocator() { return _inst->get_allocator(); }

            virtual void destroy() { 
                allocator_l0::allocator *alloc = _inst->get_allocator();
                this->~my_aio_file();
                alloc->deallocate(this);
            }

            virtual aio_task *read(char *data, dword_t size, qword_t offset) {

                if (_fd == -1 ) return 0;
                my_task *ret = static_cast<my_task *>( get_allocator()->allocate(sizeof(my_task)) );
                new ((void*)ret) my_task(data, size, offset, true, this, _fd);
                return ret;
            }
            virtual aio_task *write(char *data, dword_t size, qword_t offset) {

                if (_fd == -1 ) return 0;
                my_task *ret = static_cast<my_task *>( get_allocator()->allocate(sizeof(my_task)) );
                new ((void*)ret) my_task(data, size, offset, false, this, _fd);
                return ret;
            }
        };
    protected:
        friend class my_aio_file;
        void on_finished(my_task *task) { _done_tasks.put(task); }

        allocator_l0::allocator *get_allocator() { return _allocator; }
    public:
        linux_aio(allocator_l0::allocator *Allocator) :_allocator(Allocator) {
        }
        ~linux_aio() {
        }
        virtual void destroy() {
            allocator_l0::allocator *alloc = _allocator;
            this->~linux_aio();
            alloc->deallocate(this);
        }
        virtual aio_file *create(const char *file_name, int open_mode) {
            my_aio_file *ret = static_cast<my_aio_file *>( _allocator->allocate(sizeof(my_aio_file)) );
            new ((void*)ret) my_aio_file(file_name, open_mode, this);
            return ret;
        }
        virtual dword_t query(aio_task **task_list, dword_t count) {

            container_l0::pool_node *node = 0;
            dword_t ret = 0;
            for ( ; ret < count; ret++ ) {
                node = _done_tasks.get();
                if ( node == 0 ) break;
                my_task *task = static_cast<my_task *>(node);
                if ( task->_destroyed ) task->destroy();
                else {
                    task->_destroyed = true;
                    task_list[ret] = task;
                }
            }
            return ret;
        }

    };
    inline 
    aio *aio::create(allocator_l0::allocator *Allocator) {
        linux_aio *inst = static_cast<linux_aio *>(Allocator->allocate(sizeof(linux_aio)));
        new ((void*)inst) linux_aio(Allocator);
        return inst;
    }

}